<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>CxImage: Interpolation</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<h1>Interpolation</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___interpolation.html#gd39e748b1d3bd46a3d9b56dbb7c266b2">CxImage::OverflowMethod</a> { <br>
&nbsp;&nbsp;<a class="el" href="group___interpolation.html#ggd39e748b1d3bd46a3d9b56dbb7c266b2226db0b6525ec81e1ebde648247cbd3b">CxImage::OM_COLOR</a> = 1, 
<a class="el" href="group___interpolation.html#ggd39e748b1d3bd46a3d9b56dbb7c266b20c2b1aeb3b583712b215b0cf3474a37d">CxImage::OM_BACKGROUND</a> = 2, 
<a class="el" href="group___interpolation.html#ggd39e748b1d3bd46a3d9b56dbb7c266b22e6a6149e5086916a3ae49462103f8fb">CxImage::OM_TRANSPARENT</a> = 3, 
<a class="el" href="group___interpolation.html#ggd39e748b1d3bd46a3d9b56dbb7c266b2ef30ea178dc48eba19aca6c7809e3f36">CxImage::OM_WRAP</a> = 4, 
<br>
&nbsp;&nbsp;<a class="el" href="group___interpolation.html#ggd39e748b1d3bd46a3d9b56dbb7c266b2b39c87dbf5b8fe0f5555df9dfef189c7">CxImage::OM_REPEAT</a> = 5, 
<a class="el" href="group___interpolation.html#ggd39e748b1d3bd46a3d9b56dbb7c266b26e5e6fa4ac6de6fe05708ac28eac7498">CxImage::OM_MIRROR</a> = 6
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___interpolation.html#gc1773f400a5a7fdf87a1db1dc1aec21a">CxImage::InterpolationMethod</a> { <br>
&nbsp;&nbsp;<a class="el" href="group___interpolation.html#ggc1773f400a5a7fdf87a1db1dc1aec21a3767f94a5e8a1b717705c3968c410fdd">CxImage::IM_NEAREST_NEIGHBOUR</a> = 1, 
<a class="el" href="group___interpolation.html#ggc1773f400a5a7fdf87a1db1dc1aec21aa4499649f9bee1e553002366d5e25ce3">CxImage::IM_BILINEAR</a> = 2, 
<a class="el" href="group___interpolation.html#ggc1773f400a5a7fdf87a1db1dc1aec21a74c292a1c2e3aa4efb080f9cba663ad2">CxImage::IM_BSPLINE</a> = 3, 
<a class="el" href="group___interpolation.html#ggc1773f400a5a7fdf87a1db1dc1aec21a7d21b8f4b22cc94b2cff03484f10a2bf">CxImage::IM_BICUBIC</a> = 4, 
<br>
&nbsp;&nbsp;<a class="el" href="group___interpolation.html#ggc1773f400a5a7fdf87a1db1dc1aec21a90e865fee0a9d04c24050483d01405ec">CxImage::IM_BICUBIC2</a> = 5, 
<a class="el" href="group___interpolation.html#ggc1773f400a5a7fdf87a1db1dc1aec21a099c04608b4102743f0fbb0b0a94b01d">CxImage::IM_LANCZOS</a> = 6, 
<a class="el" href="group___interpolation.html#ggc1773f400a5a7fdf87a1db1dc1aec21a3184d1a804243d751675702b256c71a2">CxImage::IM_BOX</a> = 7, 
<a class="el" href="group___interpolation.html#ggc1773f400a5a7fdf87a1db1dc1aec21afbed836b031ecf2d4fdd04ccd49dc854">CxImage::IM_HERMITE</a> = 8, 
<br>
&nbsp;&nbsp;<a class="el" href="group___interpolation.html#ggc1773f400a5a7fdf87a1db1dc1aec21a05b1ee5be08d9cb3b58a66780115f0d3">CxImage::IM_HAMMING</a> = 9, 
<a class="el" href="group___interpolation.html#ggc1773f400a5a7fdf87a1db1dc1aec21a1d0e0b2bf6de83d5047eeac375a6f711">CxImage::IM_SINC</a> = 10, 
<a class="el" href="group___interpolation.html#ggc1773f400a5a7fdf87a1db1dc1aec21a46a9f7d9aeb69882a0dcdea38c00735c">CxImage::IM_BLACKMAN</a> = 11, 
<a class="el" href="group___interpolation.html#ggc1773f400a5a7fdf87a1db1dc1aec21a33c555e6ec22dfab8b10233a4ace25a5">CxImage::IM_BESSEL</a> = 12, 
<br>
&nbsp;&nbsp;<a class="el" href="group___interpolation.html#ggc1773f400a5a7fdf87a1db1dc1aec21ade1e9f2455d5026222ec8cbdfefaba33">CxImage::IM_GAUSSIAN</a> = 13, 
<a class="el" href="group___interpolation.html#ggc1773f400a5a7fdf87a1db1dc1aec21a4785aaea47b15d81eb10f38f6718c40a">CxImage::IM_QUADRATIC</a> = 14, 
<a class="el" href="group___interpolation.html#ggc1773f400a5a7fdf87a1db1dc1aec21ac426dfa14030fca253fc9ab45cd6c5f0">CxImage::IM_MITCHELL</a> = 15, 
<a class="el" href="group___interpolation.html#ggc1773f400a5a7fdf87a1db1dc1aec21a6708bb99f8ce30239eceed906dea2337">CxImage::IM_CATROM</a> = 16, 
<br>
&nbsp;&nbsp;<a class="el" href="group___interpolation.html#ggc1773f400a5a7fdf87a1db1dc1aec21ae0abd371f68b0f1973a685290c318b65">CxImage::IM_HANNING</a> = 17, 
<a class="el" href="group___interpolation.html#ggc1773f400a5a7fdf87a1db1dc1aec21a1f6b47db54cc6ef85ddc695c3b08862a">CxImage::IM_POWER</a> = 18
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___interpolation.html#g21764b6624a83be7441228ced5765cd3">CxImage::OverflowCoordinates</a> (float &amp;x, float &amp;y, OverflowMethod const ofMethod)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___interpolation.html#gc201933daa5e60a3b779f5fb787be0f0">CxImage::OverflowCoordinates</a> (int32_t &amp;x, int32_t &amp;y, OverflowMethod const ofMethod)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">RGBQUAD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___interpolation.html#g34e92a9d6219ab2221fb1117733dc8a7">CxImage::GetPixelColorWithOverflow</a> (int32_t x, int32_t y, OverflowMethod const ofMethod=OM_BACKGROUND, RGBQUAD *const rplColor=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">RGBQUAD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___interpolation.html#gfc0c7822ecc90053d43cb5104ff4e65b">CxImage::GetPixelColorInterpolated</a> (float x, float y, InterpolationMethod const inMethod=IM_BILINEAR, OverflowMethod const ofMethod=OM_BACKGROUND, RGBQUAD *const rplColor=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">RGBQUAD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___interpolation.html#g3bc8408f5b20816d581e011638f9681e">CxImage::GetAreaColorInterpolated</a> (float const xc, float const yc, float const w, float const h, InterpolationMethod const inMethod, OverflowMethod const ofMethod=OM_BACKGROUND, RGBQUAD *const rplColor=0)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="gc1773f400a5a7fdf87a1db1dc1aec21a"></a><!-- doxytag: member="CxImage::InterpolationMethod" ref="gc1773f400a5a7fdf87a1db1dc1aec21a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___interpolation.html#gc1773f400a5a7fdf87a1db1dc1aec21a">CxImage::InterpolationMethod</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="ggc1773f400a5a7fdf87a1db1dc1aec21a3767f94a5e8a1b717705c3968c410fdd"></a><!-- doxytag: member="IM_NEAREST_NEIGHBOUR" ref="ggc1773f400a5a7fdf87a1db1dc1aec21a3767f94a5e8a1b717705c3968c410fdd" args="" -->IM_NEAREST_NEIGHBOUR</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc1773f400a5a7fdf87a1db1dc1aec21aa4499649f9bee1e553002366d5e25ce3"></a><!-- doxytag: member="IM_BILINEAR" ref="ggc1773f400a5a7fdf87a1db1dc1aec21aa4499649f9bee1e553002366d5e25ce3" args="" -->IM_BILINEAR</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc1773f400a5a7fdf87a1db1dc1aec21a74c292a1c2e3aa4efb080f9cba663ad2"></a><!-- doxytag: member="IM_BSPLINE" ref="ggc1773f400a5a7fdf87a1db1dc1aec21a74c292a1c2e3aa4efb080f9cba663ad2" args="" -->IM_BSPLINE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc1773f400a5a7fdf87a1db1dc1aec21a7d21b8f4b22cc94b2cff03484f10a2bf"></a><!-- doxytag: member="IM_BICUBIC" ref="ggc1773f400a5a7fdf87a1db1dc1aec21a7d21b8f4b22cc94b2cff03484f10a2bf" args="" -->IM_BICUBIC</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc1773f400a5a7fdf87a1db1dc1aec21a90e865fee0a9d04c24050483d01405ec"></a><!-- doxytag: member="IM_BICUBIC2" ref="ggc1773f400a5a7fdf87a1db1dc1aec21a90e865fee0a9d04c24050483d01405ec" args="" -->IM_BICUBIC2</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc1773f400a5a7fdf87a1db1dc1aec21a099c04608b4102743f0fbb0b0a94b01d"></a><!-- doxytag: member="IM_LANCZOS" ref="ggc1773f400a5a7fdf87a1db1dc1aec21a099c04608b4102743f0fbb0b0a94b01d" args="" -->IM_LANCZOS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc1773f400a5a7fdf87a1db1dc1aec21a3184d1a804243d751675702b256c71a2"></a><!-- doxytag: member="IM_BOX" ref="ggc1773f400a5a7fdf87a1db1dc1aec21a3184d1a804243d751675702b256c71a2" args="" -->IM_BOX</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc1773f400a5a7fdf87a1db1dc1aec21afbed836b031ecf2d4fdd04ccd49dc854"></a><!-- doxytag: member="IM_HERMITE" ref="ggc1773f400a5a7fdf87a1db1dc1aec21afbed836b031ecf2d4fdd04ccd49dc854" args="" -->IM_HERMITE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc1773f400a5a7fdf87a1db1dc1aec21a05b1ee5be08d9cb3b58a66780115f0d3"></a><!-- doxytag: member="IM_HAMMING" ref="ggc1773f400a5a7fdf87a1db1dc1aec21a05b1ee5be08d9cb3b58a66780115f0d3" args="" -->IM_HAMMING</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc1773f400a5a7fdf87a1db1dc1aec21a1d0e0b2bf6de83d5047eeac375a6f711"></a><!-- doxytag: member="IM_SINC" ref="ggc1773f400a5a7fdf87a1db1dc1aec21a1d0e0b2bf6de83d5047eeac375a6f711" args="" -->IM_SINC</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc1773f400a5a7fdf87a1db1dc1aec21a46a9f7d9aeb69882a0dcdea38c00735c"></a><!-- doxytag: member="IM_BLACKMAN" ref="ggc1773f400a5a7fdf87a1db1dc1aec21a46a9f7d9aeb69882a0dcdea38c00735c" args="" -->IM_BLACKMAN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc1773f400a5a7fdf87a1db1dc1aec21a33c555e6ec22dfab8b10233a4ace25a5"></a><!-- doxytag: member="IM_BESSEL" ref="ggc1773f400a5a7fdf87a1db1dc1aec21a33c555e6ec22dfab8b10233a4ace25a5" args="" -->IM_BESSEL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc1773f400a5a7fdf87a1db1dc1aec21ade1e9f2455d5026222ec8cbdfefaba33"></a><!-- doxytag: member="IM_GAUSSIAN" ref="ggc1773f400a5a7fdf87a1db1dc1aec21ade1e9f2455d5026222ec8cbdfefaba33" args="" -->IM_GAUSSIAN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc1773f400a5a7fdf87a1db1dc1aec21a4785aaea47b15d81eb10f38f6718c40a"></a><!-- doxytag: member="IM_QUADRATIC" ref="ggc1773f400a5a7fdf87a1db1dc1aec21a4785aaea47b15d81eb10f38f6718c40a" args="" -->IM_QUADRATIC</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc1773f400a5a7fdf87a1db1dc1aec21ac426dfa14030fca253fc9ab45cd6c5f0"></a><!-- doxytag: member="IM_MITCHELL" ref="ggc1773f400a5a7fdf87a1db1dc1aec21ac426dfa14030fca253fc9ab45cd6c5f0" args="" -->IM_MITCHELL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc1773f400a5a7fdf87a1db1dc1aec21a6708bb99f8ce30239eceed906dea2337"></a><!-- doxytag: member="IM_CATROM" ref="ggc1773f400a5a7fdf87a1db1dc1aec21a6708bb99f8ce30239eceed906dea2337" args="" -->IM_CATROM</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc1773f400a5a7fdf87a1db1dc1aec21ae0abd371f68b0f1973a685290c318b65"></a><!-- doxytag: member="IM_HANNING" ref="ggc1773f400a5a7fdf87a1db1dc1aec21ae0abd371f68b0f1973a685290c318b65" args="" -->IM_HANNING</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggc1773f400a5a7fdf87a1db1dc1aec21a1f6b47db54cc6ef85ddc695c3b08862a"></a><!-- doxytag: member="IM_POWER" ref="ggc1773f400a5a7fdf87a1db1dc1aec21a1f6b47db54cc6ef85ddc695c3b08862a" args="" -->IM_POWER</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="gd39e748b1d3bd46a3d9b56dbb7c266b2"></a><!-- doxytag: member="CxImage::OverflowMethod" ref="gd39e748b1d3bd46a3d9b56dbb7c266b2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___interpolation.html#gd39e748b1d3bd46a3d9b56dbb7c266b2">CxImage::OverflowMethod</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="ggd39e748b1d3bd46a3d9b56dbb7c266b2226db0b6525ec81e1ebde648247cbd3b"></a><!-- doxytag: member="OM_COLOR" ref="ggd39e748b1d3bd46a3d9b56dbb7c266b2226db0b6525ec81e1ebde648247cbd3b" args="" -->OM_COLOR</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggd39e748b1d3bd46a3d9b56dbb7c266b20c2b1aeb3b583712b215b0cf3474a37d"></a><!-- doxytag: member="OM_BACKGROUND" ref="ggd39e748b1d3bd46a3d9b56dbb7c266b20c2b1aeb3b583712b215b0cf3474a37d" args="" -->OM_BACKGROUND</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggd39e748b1d3bd46a3d9b56dbb7c266b22e6a6149e5086916a3ae49462103f8fb"></a><!-- doxytag: member="OM_TRANSPARENT" ref="ggd39e748b1d3bd46a3d9b56dbb7c266b22e6a6149e5086916a3ae49462103f8fb" args="" -->OM_TRANSPARENT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggd39e748b1d3bd46a3d9b56dbb7c266b2ef30ea178dc48eba19aca6c7809e3f36"></a><!-- doxytag: member="OM_WRAP" ref="ggd39e748b1d3bd46a3d9b56dbb7c266b2ef30ea178dc48eba19aca6c7809e3f36" args="" -->OM_WRAP</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggd39e748b1d3bd46a3d9b56dbb7c266b2b39c87dbf5b8fe0f5555df9dfef189c7"></a><!-- doxytag: member="OM_REPEAT" ref="ggd39e748b1d3bd46a3d9b56dbb7c266b2b39c87dbf5b8fe0f5555df9dfef189c7" args="" -->OM_REPEAT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggd39e748b1d3bd46a3d9b56dbb7c266b26e5e6fa4ac6de6fe05708ac28eac7498"></a><!-- doxytag: member="OM_MIRROR" ref="ggd39e748b1d3bd46a3d9b56dbb7c266b26e5e6fa4ac6de6fe05708ac28eac7498" args="" -->OM_MIRROR</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g3bc8408f5b20816d581e011638f9681e"></a><!-- doxytag: member="CxImage::GetAreaColorInterpolated" ref="g3bc8408f5b20816d581e011638f9681e" args="(float const xc, float const yc, float const w, float const h, InterpolationMethod const inMethod, OverflowMethod const ofMethod=OM_BACKGROUND, RGBQUAD *const rplColor=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RGBQUAD CxImage::GetAreaColorInterpolated           </td>
          <td>(</td>
          <td class="paramtype">float const &nbsp;</td>
          <td class="paramname"> <em>xc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float const &nbsp;</td>
          <td class="paramname"> <em>yc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float const &nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float const &nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___interpolation.html#gc1773f400a5a7fdf87a1db1dc1aec21a">InterpolationMethod</a> const &nbsp;</td>
          <td class="paramname"> <em>inMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___interpolation.html#gd39e748b1d3bd46a3d9b56dbb7c266b2">OverflowMethod</a> const &nbsp;</td>
          <td class="paramname"> <em>ofMethod</em> = <code>OM_BACKGROUND</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RGBQUAD *const &nbsp;</td>
          <td class="paramname"> <em>rplColor</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is similar to GetPixelColorInterpolated, but this method also properly handles subsampling. If you need to sample original image with interval of more than 1 pixel (as when shrinking an image), you should use this method instead of GetPixelColorInterpolated or aliasing will occur. When area width and height are both less than pixel, this method gets pixel color by interpolating color of frame center with selected (inMethod) interpolation by calling GetPixelColorInterpolated. If width and height are more than 1, method calculates color by averaging color of pixels within area. Interpolation method is not used in this case. Pixel color is interpolated by averaging instead. If only one of both is more than 1, method uses combination of interpolation and averaging. Chosen interpolation method is used, but since it is averaged later on, there is little difference between IM_BILINEAR (perhaps best for this case) and better methods. IM_NEAREST_NEIGHBOUR again leads to aliasing artifacts. This method is a bit slower than GetPixelColorInterpolated and when aliasing is not a problem, you should simply use the later.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xc,yc</em>&nbsp;</td><td>- center of (rectangular) area </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>w,h</em>&nbsp;</td><td>- width and height of area </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inMethod</em>&nbsp;</td><td>- interpolation method that is used, when interpolation is used (see above) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ofMethod</em>&nbsp;</td><td>- overflow method used when retrieving individual pixel colors </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rplColor</em>&nbsp;</td><td>- replacement colour to use, in OM_COLOR</td></tr>
  </table>
</dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>***bd*** 2.2004 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gfc0c7822ecc90053d43cb5104ff4e65b"></a><!-- doxytag: member="CxImage::GetPixelColorInterpolated" ref="gfc0c7822ecc90053d43cb5104ff4e65b" args="(float x, float y, InterpolationMethod const inMethod=IM_BILINEAR, OverflowMethod const ofMethod=OM_BACKGROUND, RGBQUAD *const rplColor=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RGBQUAD CxImage::GetPixelColorInterpolated           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___interpolation.html#gc1773f400a5a7fdf87a1db1dc1aec21a">InterpolationMethod</a> const &nbsp;</td>
          <td class="paramname"> <em>inMethod</em> = <code>IM_BILINEAR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___interpolation.html#gd39e748b1d3bd46a3d9b56dbb7c266b2">OverflowMethod</a> const &nbsp;</td>
          <td class="paramname"> <em>ofMethod</em> = <code>OM_BACKGROUND</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RGBQUAD *const &nbsp;</td>
          <td class="paramname"> <em>rplColor</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method reconstructs image according to chosen interpolation method and then returns pixel (x,y). (x,y) can lie between actual image pixels. If (x,y) lies outside of image, method returns value according to overflow method. This method is very useful for geometrical image transformations, where destination pixel can often assume color value lying between source pixels.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>(x,y)</em>&nbsp;</td><td>- coordinates of pixel to return GPCI method recreates "analogue" image back from digital data, so x and y are float values and color value of point (1.1,1) will generally not be same as (1,1). Center of first pixel is at (0,0) and center of pixel right to it is (1,0). (0.5,0) is half way between these two pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inMethod</em>&nbsp;</td><td>- interpolation (reconstruction) method (kernel) to use:<ul>
<li>IM_NEAREST_NEIGHBOUR - returns colour of nearest lying pixel (causes stairy look of processed images)</li><li>IM_BILINEAR - interpolates colour from four neighbouring pixels (softens image a bit)</li><li>IM_BICUBIC - interpolates from 16 neighbouring pixels (can produce "halo" artifacts)</li><li>IM_BICUBIC2 - interpolates from 16 neighbouring pixels (perhaps a bit less halo artifacts than IM_BICUBIC)</li><li>IM_BSPLINE - interpolates from 16 neighbouring pixels (softens image, washes colours) (As far as I know, image should be prefiltered for this method to give good results... some other time :) ) This method uses bicubic interpolation kernel from CXImage 5.99a and older versions.</li><li>IM_LANCZOS - interpolates from 12*12 pixels (slow, ringing artifacts)</li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ofMethod</em>&nbsp;</td><td>- overflow method (see comments at GetPixelColorWithOverflow) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rplColor</em>&nbsp;</td><td>- pointer to color used for out of borders pixels in OM_COLOR mode (and other modes if colour can't calculated in a specified way)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>interpolated color value (including interpolated alpha value, if image has alpha layer)</dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>***bd*** 2.2004 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g34e92a9d6219ab2221fb1117733dc8a7"></a><!-- doxytag: member="CxImage::GetPixelColorWithOverflow" ref="g34e92a9d6219ab2221fb1117733dc8a7" args="(int32_t x, int32_t y, OverflowMethod const ofMethod=OM_BACKGROUND, RGBQUAD *const rplColor=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RGBQUAD CxImage::GetPixelColorWithOverflow           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___interpolation.html#gd39e748b1d3bd46a3d9b56dbb7c266b2">OverflowMethod</a> const &nbsp;</td>
          <td class="paramname"> <em>ofMethod</em> = <code>OM_BACKGROUND</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RGBQUAD *const &nbsp;</td>
          <td class="paramname"> <em>rplColor</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Method return pixel color. Different methods are implemented for out of bounds pixels. If an image has alpha channel, alpha value is returned in .RGBReserved.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x,y</em>&nbsp;</td><td>: pixel coordinates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ofMethod</em>&nbsp;</td><td>: out-of-bounds method:<ul>
<li>OF_WRAP - wrap over to pixels on other side of the image</li><li>OF_REPEAT - repeat last pixel on the edge</li><li>OF_COLOR - return input value of color</li><li>OF_BACKGROUND - return background color (if not set, return input color)</li><li>OF_TRANSPARENT - return transparent pixel</li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rplColor</em>&nbsp;</td><td>: input color (returned for out-of-bound coordinates in OF_COLOR mode and if other mode is not applicable)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>color : color of pixel </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>***bd*** 2.2004 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc201933daa5e60a3b779f5fb787be0f0"></a><!-- doxytag: member="CxImage::OverflowCoordinates" ref="gc201933daa5e60a3b779f5fb787be0f0" args="(int32_t &amp;x, int32_t &amp;y, OverflowMethod const ofMethod)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CxImage::OverflowCoordinates           </td>
          <td>(</td>
          <td class="paramtype">int32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___interpolation.html#gd39e748b1d3bd46a3d9b56dbb7c266b2">OverflowMethod</a> const &nbsp;</td>
          <td class="paramname"> <em>ofMethod</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recalculates coordinates according to specified overflow method. If pixel (x,y) lies within image, nothing changes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x,y</em>&nbsp;</td><td>- coordinates of pixel </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ofMethod</em>&nbsp;</td><td>- overflow method</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>x, y - new coordinates (pixel (x,y) now lies inside image)</dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>***bd*** 2.2004 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g21764b6624a83be7441228ced5765cd3"></a><!-- doxytag: member="CxImage::OverflowCoordinates" ref="g21764b6624a83be7441228ced5765cd3" args="(float &amp;x, float &amp;y, OverflowMethod const ofMethod)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CxImage::OverflowCoordinates           </td>
          <td>(</td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___interpolation.html#gd39e748b1d3bd46a3d9b56dbb7c266b2">OverflowMethod</a> const &nbsp;</td>
          <td class="paramname"> <em>ofMethod</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
See OverflowCoordinates for integer version <dl class="author" compact><dt><b>Author:</b></dt><dd>***bd*** 2.2004 </dd></dl>

</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jan 7 21:44:32 2011 for CxImage by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.4 </small></address>
</body>
</html>
